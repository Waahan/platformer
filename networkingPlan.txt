Plan for the networking code
HEADER File

defined types between unix and winsock
socketType is socket SOCKET for windows and in for unix

Init function has nothing if not windows returns a initGuard to close 

class networkConfig
    constructor that takes sockaddr
    constructor that zeros sockaddr struct

    setIpVersion(ipVersion)

    setIpAddress(string) 
    setPort(short)

    sockaddrRep()
    size()

    private:
    ipVersion currentIpVersion

    union 
        sockaddr_in socketAddressIpv4
        sockaddr_in6 socketAddressIpv6

class networkingExchange
    send(string)
    receive(string)

operator<<(networkingExchange, string)
operator>>(networkingExchange, string)

class serverClient
{
    networkingConfig
    socketType socketHandle

    destructor that closes socket handle
}

class server : networkingExchange
    constructor takes ipversion, protocal (tcp or udp) and port

    listen(backlog = 0)

    bool pendingConnection() use select with fd_set

    string accept() return the uuid of the new client

    canReceive()

    send(string) global send
    receive(string) global receive

    sendTo(string, uuid)
    receiveFrom(string, uuid)
    
    closeClientConnection(uuid) remove a client from the map

    stop() close all client connection and server connections

    private:
    ipVersion
    socketType socketHandle
    fd_set readSocketFrom

    map of clients using uuids and serverClient struct 

class client : networkingExchange
    constructor that takes ipVersion and the protocal must bind port when using udp
    
    connect(networkingConfig server)

    send(string)
    receive(string)

    sendTo(string, networkingConfig)
    receiveFrom(string, networkingConfig)

    close()

    private:
    ipVersion
    socketType socketHandle

SRC File
int networkingErrorCode()
    for windows returns WSAGetLastError and for unix returns errno

type is tcp or udp
socketType socket(ipVersion, type, protocal = 0)
    newSocket  = socket()

    define constexpr notSocket is -1 for unix or INVALID_SOCKET for windows

    if notSocket 
        call networkingErrorCode if failed

    return newSocket

void closeSocket(socketType)
    if windows call closesocket 
    else if unix call close

    check if the return value is 0
        if it isn't call networkingErrorCode

void bind(socketType, networkingConfig)
    bind socket
    handle if does not return 0
    

renames for network and host number conversion

hostToNetworkShort htons
HostToNetworkLong htonl
networkToHostShort ntohs
networkToHostLong ntohl

void ipAddressToBinary(ipVersion, const std::string& ipAddressString, void* destination)
    check dest is a valid pointer
    make sure ipVersion is ipv4 or ipv6

    make sure inet_pton returns 1
        if it does not call getNetworkingError

string binaryToIpAddress(ipVersion, void* binaryIp)
    check binaryIp is not null
    check if ipVersion is ipv4 or ipv6

    writeTo should be at least be able to handle 46 characters

    make sure inet_ntop does not return NULL if it does call networkingErrorCode

    create a string from writeTo and return it

connectionStatus sendString(socketType, const std::string& buffer, networkingConfig* recipient)
    get the max using sizeof(std::string::value_type) and buffer.size

    use sendto but check if recipient is null

connectionStatus recieveString(socketType, std::string& buffer, networkingConfig* sender, const int max)
    allocate some char memory 
    get the size by multiplying sizeof(char) * max

    use recvfrom
